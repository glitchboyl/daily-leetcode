<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>minimum-moves-to-equal-array-elements</title>
  </head>
  <body>
    <div><div><p>给定一个长度为 <em>n</em> 的<strong>非空</strong>整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 <em>n</em> - 1 个元素增加 1。</p>

      <p><strong>示例:</strong></p>
      
      <pre><strong>输入:</strong>
[1,2,3]
      
<strong>输出:</strong>
3
      
<strong>解释:</strong>
只需要3次移动（注意每次移动会增加两个元素的值）：
      
[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]
      </pre>
      </div></div>
    <div style="margin: 50px 0; padding: 10px; border: 1px solid;">
        <strong>解题思路:</strong><br />
        我的第一种解法比较简单粗暴，排序之后将 (n - 1) 个元素加 1，循环此过程直至排重之后只剩下一项所需的步数就是答案。<br />
        但如果一旦数组中的最大值超出某个范围，循环所带来的消耗会使得页面超时卡死。所以这种解法暴力不可取。<br />
        <br />
        第二种解法，是最优解法。但是我的答案并不是最佳写法。<br />
        (n + 1) 个元素加 1 之后，实际上可以反向理解成最大值减去 1：<br />
        <pre>
[1,2,3]  =&gt;  [2,3,3]  所有项减去 1 后=&gt;  [1,2,2]
        </pre>
        因此其实只要所有值都等于最小值时，数组就相等了。<br />
        所以最后得出的结论是<strong>其余项与最小值的差的总和就是移动的步数</strong>。
    </div>
    <div>
      来源：力扣（LeetCode）<br />
      链接：<a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements"
        >https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements</a
      ><br />
    </div>
  </body>
  <script src="./index.js"></script>
</html>
